/**
 * Redis Cache Service
 * Production-grade caching with Redis
 */

import Redis from 'ioredis';

const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
const DEFAULT_TTL = 300; // 5 minutes

let redis: Redis | null = null;

// ============================================
// REDIS CLIENT
// ============================================

export function getRedisClient(): Redis {
  if (!redis) {
    redis = new Redis(REDIS_URL, {
      maxRetriesPerRequest: 3,
      enableReadyCheck: true,
      retryStrategy(times) {
        const delay = Math.min(times * 50, 2000);
        return delay;
      },
    });

    redis.on('connect', () => {
      console.log('[redis] ✅ Connected to Redis');
    });

    redis.on('error', (err) => {
      console.error('[redis] ❌ Redis error:', err);
    });
  }

  return redis;
}

// ============================================
// CACHE OPERATIONS
// ============================================

export async function cacheGet<T>(key: string): Promise<T | null> {
  try {
    const client = getRedisClient();
    const value = await client.get(key);
    
    if (!value) return null;
    
    return JSON.parse(value) as T;
  } catch (err) {
    console.error('[redis] Get error:', err);
    return null;
  }
}

export async function cacheSet(
  key: string,
  value: any,
  ttl: number = DEFAULT_TTL
): Promise<boolean> {
  try {
    const client = getRedisClient();
    const serialized = JSON.stringify(value);
    
    await client.setex(key, ttl, serialized);
    return true;
  } catch (err) {
    console.error('[redis] Set error:', err);
    return false;
  }
}

export async function cacheDel(key: string): Promise<boolean> {
  try {
    const client = getRedisClient();
    await client.del(key);
    return true;
  } catch (err) {
    console.error('[redis] Delete error:', err);
    return false;
  }
}

export async function cacheDelPattern(pattern: string): Promise<number> {
  try {
    const client = getRedisClient();
    const keys = await client.keys(pattern);
    
    if (keys.length === 0) return 0;
    
    await client.del(...keys);
    return keys.length;
  } catch (err) {
    console.error('[redis] Delete pattern error:', err);
    return 0;
  }
}

// ============================================
// CACHE DECORATORS
// ============================================

export function withRedisCache(ttl: number = DEFAULT_TTL) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const key = `cache:${propertyKey}:${JSON.stringify(args)}`;
      
      // Try cache first
      const cached = await cacheGet(key);
      if (cached !== null) {
        return cached;
      }

      // Execute and cache result
      const result = await originalMethod.apply(this, args);
      await cacheSet(key, result, ttl);
      
      return result;
    };

    return descriptor;
  };
}

// ============================================
// STATS
// ============================================

export async function getRedisStats(): Promise<{
  connected: boolean;
  keys: number;
  memory_mb: number;
  uptime_seconds: number;
}> {
  try {
    const client = getRedisClient();
    const info = await client.info('stats');
    const dbsize = await client.dbsize();
    
    return {
      connected: true,
      keys: dbsize,
      memory_mb: 0, // Parse from info
      uptime_seconds: 0, // Parse from info
    };
  } catch (err) {
    return {
      connected: false,
      keys: 0,
      memory_mb: 0,
      uptime_seconds: 0,
    };
  }
}

export const RedisCache = {
  get: cacheGet,
  set: cacheSet,
  del: cacheDel,
  delPattern: cacheDelPattern,
  getStats: getRedisStats,
  withCache: withRedisCache,
};

export default RedisCache;
